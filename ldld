local G_DEBUG = false

getgenv().print = function() end
getgenv().warn = function() end
getgenv().error = function() end

local function silenceOutput()
    if not G_DEBUG then
        print = function() end
        warn = function() end
        error = function() end
        if rconsoleprint then
            rconsoleprint = function() end
            rconsolewarn = function() end
            rconsoleerr = function() end
        end
    end
end

if not G_DEBUG then
    silenceOutput()
end

if not G_DEBUG then 
    if _G.ScriptExecuted then
        return
    end
    _G.ScriptExecuted = true
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Lighting = game:GetService("Lighting")
allToggles = {}

task.spawn(function()
    local Sound = Instance.new("Sound")
    Sound.SoundId = "http://www.roblox.com/asset/?id=114127796308571"
    Sound.Volume = 0.2
    Sound.Parent = game.Workspace

    Sound:play()

    local Image = Drawing.new("Image")
    local Screen = workspace.CurrentCamera.ViewportSize

    Image.Data = game:HttpGet("https://cdn.discordapp.com/attachments/1463390019862532210/1463429588649639971/08.png?ex=69727543&is=697123c3&hm=59814217e527edf61d770e892a2195ea515aabeef22dbccad66240ac98174920&")
    Image.Visible = true
    Image.Transparency = 1
    Image.Position = Vector2.new(0,0)
    Image.Size = Vector2.new(Screen.X,Screen.Y)

    task.wait(1.2)

    for i = 1, 100 do
        Image.Transparency = 1 - (i / 110)
        task.wait(0.01)
    end

    Image:Remove()
end)

local Settings = {
    ESP = {
        enabled = true,
        boxes = false,
        names = false,
        tracers = false,
        health = false,
        teamColor = false,
        showDistance = false,
        showHealthNumber = false,
        maxDistance = 1000,
        textSize = 8,
        boxThickness = 1,
        tracerThickness = 1,
        transparency = 1,
        espFPS = 60,
        boxColor = Color3.fromRGB(255, 255, 255),
        tracerColor = Color3.fromRGB(255, 255, 255),
        healthColor = Color3.fromRGB(0, 255, 0),
        textColor = Color3.fromRGB(255, 255, 255)
    },
    
    MobileAimbot = {
        enabled = false,
        fovRadius = 150,
        rainbowEnabled = false,
        fovCircleEnabled = false,
        wallCheck = true,
        teamCheck = true,
        requireGunEquipped = false,
        sensitivity = 0.93
    },
    
    Aimbot = {
        enabled = false,
        fov = 65,
        showFOV = false,
        teamCheck = true,
        requireGunEquipped = true,
        wallCheck = true,
        deathCheck = true,
        forcefieldCheck = false,
        targetPart = "Head"
    },
    
    Movement = {
        walkSpeedEnabled = false,
        walkSpeedValue = 0.09,
        noclipEnabled = false,
        infiniteJumpEnabled = false
    },
    
    Misc = {
        hitboxExpanderEnabled = false,
        headScale = 0.3,
        bodyScale = 0.15,
        chatSpyEnabled = false,
        fpsLimit = 500,
        antiAfkEnabled = false,
        fovValue = 70
    },
    
    Map = {
        fullBrightEnabled = false,
        fullBrightPercent = 100
    },
    
    AntiMod = {
        modJoinNotify = true,
        disableOnModJoin = true,
        resetOnModJoin = false,
        autoLeave = false
    }
}

UIElements = {}

StepDelay = 0.2 

perf = {
    cachedPlayers = {},
    lastPlayerUpdate = 0,
    playerUpdateInterval = 0.5,
    espUpdateThrottle = 0,
    espFPS = 60,
    espThrottleInterval = 1,
    lastAimbotUpdate = 0,
    aimbotUpdateInterval = 0.016
}
GROUP_ID = 5479038
MODERATOR_RANK_THRESHOLD = 248

local function isModerator(player)
    if not player or not player.Parent then
        return false
    end
    
    local success, rank = pcall(function()
        return player:GetRankInGroup(GROUP_ID)
    end)

    if success and rank then
        return rank >= MODERATOR_RANK_THRESHOLD
    end
    
    return false
end

local function updatePlayerCache()
    local currentTime = tick()
    if currentTime - perf.lastPlayerUpdate < perf.playerUpdateInterval then
        return perf.cachedPlayers
    end

    perf.lastPlayerUpdate = currentTime
    perf.cachedPlayers = Players:GetPlayers()
    return perf.cachedPlayers
end

local function getPlayers()
    return updatePlayerCache()
end

local function disableAllToggles()
    for _, toggle in pairs(allToggles) do
        if toggle.CurrentValue then
            toggle:Set(false)
        end
    end
end

local Connection

local function InfiniteJump()
    local Character = LocalPlayer.Character
    if not Character then return end

    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
    if not Humanoid then return end

    Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

    local RootPart = Character:FindFirstChild("HumanoidRootPart")
    if RootPart then
        local jumpPower = 50
        RootPart.Velocity = Vector3.new(RootPart.Velocity.X, jumpPower, RootPart.Velocity.Z)
    end
end

local InfiniteJumpEnabled = false

local function setfpscap(fps)
    if syn and syn.setfpscap then
        syn.setfpscap(fps)
    elseif setfpscap then
        setfpscap(fps)
    elseif settings then
        settings().Rendering.Framerate = fps
    end
end

classDAndChaosInsurgency = { "Class - D", "Chaos Insurgency" }

local otherTeams = { 
    "Security Department", 
    "Mobile Task Force", 
    "Internal Security Department", 
    "Administrative Department", 
    "Intelligence Agency", 
    "Rapid Response Team", 
    "Scientific Department", 
    "Medical Department" 
}

local Mouse = LocalPlayer:GetMouse()
local aimbot = {
    CurrentTarget = nil,
    IsAiming = false,
    GunEquipped = false,
    LastTargetCheck = 0,
    TargetCheckDelay = 0.01,
    DeadTargets = {}
}

mobileAimbotConnection = nil
mobileFovRadius = Settings.MobileAimbot.fovRadius
mobileFovCircle = nil
mobileRainbowEnabled = Settings.MobileAimbot.rainbowEnabled
mobileHue = 0

function registerUIElement(name, element)
    UIElements[name] = element
end

function updateUIElement(name, value)
    local element = UIElements[name]
    if element then
        pcall(function()
            if element.Set then
                element:Set(value)
            elseif element.CurrentValue then
                element.CurrentValue = value
                if element.Callback then
                    element.Callback(value)
                end
            end
        end)
    end
end

function updateColorPicker(name, value)
    local element = UIElements[name]
    if element then
        pcall(function()
            if element.Set then
                element:Set(value)
            else
                element.Color = value
                if element.Callback then
                    element.Callback(value)
                end
            end
        end)
    end
end

function updateSliderValue(sliderName, value)
    local slider = UIElements[sliderName]
    if slider then
        pcall(function()
            print("Updating slider:", sliderName, "to value:", value)
            
            if slider.Set then
                slider:Set(value)
                print("Slider", sliderName, "updated using Set method")
            else
                print("Slider", sliderName, "does not have Set method")
            end
        end)
    else
        print("Slider not found:", sliderName)
    end
end

local detectedMods = {}

for _, player in ipairs(getPlayers()) do
    if isModerator(player) then
        if not detectedMods[player.UserId] then
            detectedMods[player.UserId] = true
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    wait(2)
    if isModerator(player) then
        if not detectedMods[player.UserId] then
            detectedMods[player.UserId] = true
        end
    end
end)

local function CreateHighlight()
    local highlight = Instance.new("Highlight")
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.FillColor = Color3.fromRGB(255, 0, 0)
    highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
    highlight.Enabled = false
    highlight.Parent = game:GetService("CoreGui")
    return highlight
end

local HighlightInstance = CreateHighlight()

local function randomString(len)
    local chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    local s = ''
    for i = 1, len do
        local r = math.random(1, #chars)
        s = s .. chars:sub(r, r)
    end
    return s
end

local Rayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/axleoislost/Rayfield/refs/heads/main/Rayfield.lua"))()
if Rayfield and Rayfield.UI then
    Rayfield.UI.Name = randomString(16)

    local hiddenFolder = game:GetService("CoreGui"):FindFirstChild("_UIH")
    if not hiddenFolder then
        hiddenFolder = Instance.new("Folder")
        hiddenFolder.Name = randomString(12)
        hiddenFolder.Parent = game:GetService("ReplicatedStorage")
    end
    Rayfield.UI.Parent = hiddenFolder
end

local ESP = {
    enabled = Settings.ESP.enabled,
    boxes = Settings.ESP.boxes,
    names = Settings.ESP.names,
    tracers = Settings.ESP.tracers,
    health = Settings.ESP.health,
    teamColor = Settings.ESP.teamColor,
    showDistance = Settings.ESP.showDistance,
    showHealthNumber = Settings.ESP.showHealthNumber,
    maxDistance = Settings.ESP.maxDistance,
    boxElements = {},
    nameElements = {},
    tracerElements = {},
    healthElements = {},
    settings = {
        textSize = Settings.ESP.textSize,
        boxThickness = Settings.ESP.boxThickness,
        tracerThickness = Settings.ESP.tracerThickness,
        transparency = Settings.ESP.transparency,
    },
    colors = {
        box = Settings.ESP.boxColor,
        tracer = Settings.ESP.tracerColor,
        health = Settings.ESP.healthColor,
        text = Settings.ESP.textColor
    }
}

local Vector2new = Vector2.new
local Vector3new = Vector3.new
local Color3new = Color3.new
local mathfloor = math.floor
local stringformat = string.format
local tableremove = table.remove

local function formatDistance(distance)
    return stringformat("%.0f", distance)
end

local function getHealthColor(health, maxHealth)
    local healthPercent = health / maxHealth
    if healthPercent > 0.6 then
        return Color3.fromRGB(0, 255, 0) 
    elseif healthPercent > 0.3 then
        return Color3.fromRGB(255, 165, 0) 
    else
        return Color3.fromRGB(255, 0, 0) 
    end
end

local function cleanupAllESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if ESP.boxElements[player] then
            ESP.boxElements[player].Visible = false
            ESP.nameElements[player].Visible = false
            ESP.tracerElements[player].Visible = false

            local healthBar = ESP.healthElements[player]
            if healthBar then
                healthBar.background.Visible = false
                healthBar.fill.Visible = false
                healthBar.outline.Visible = false
                healthBar.text.Visible = false
            end
        end
    end
end

local function cleanupESPElement(player)
    local elements = ESP.boxElements[player]
    if elements then
        ESP.boxElements[player]:Remove()
        ESP.nameElements[player]:Remove()
        ESP.tracerElements[player]:Remove()

        local healthElements = ESP.healthElements[player]
        if healthElements then
            healthElements.background:Remove()
            healthElements.fill:Remove()
            healthElements.outline:Remove()
            healthElements.text:Remove()
        end

        ESP.boxElements[player] = nil
        ESP.nameElements[player] = nil
        ESP.tracerElements[player] = nil
        ESP.healthElements[player] = nil
    end
end

local function createESPElement(player)
    if not ESP.boxElements[player] then
        local box = Drawing.new("Square")
        box.Thickness = ESP.settings.boxThickness
        box.Filled = false
        box.Transparency = ESP.settings.transparency
        ESP.boxElements[player] = box

        local name = Drawing.new("Text")
        name.Size = ESP.settings.textSize
        name.Center = true
        name.Outline = true
        name.Transparency = ESP.settings.transparency
        ESP.nameElements[player] = name

        local tracer = Drawing.new("Line")
        tracer.Thickness = ESP.settings.tracerThickness
        tracer.Transparency = ESP.settings.transparency
        ESP.tracerElements[player] = tracer

        local healthBar = {
            background = Drawing.new("Square"),
            fill = Drawing.new("Square"),
            outline = Drawing.new("Square"),
            text = Drawing.new("Text")
        }

        healthBar.background.Filled = true
        healthBar.background.Color = Color3new(0, 0, 0)
        healthBar.background.Transparency = ESP.settings.transparency

        healthBar.fill.Filled = true
        healthBar.fill.Transparency = ESP.settings.transparency

        healthBar.outline.Thickness = 1
        healthBar.outline.Filled = false
        healthBar.outline.Color = Color3new(0, 0, 0)
        healthBar.outline.Transparency = ESP.settings.transparency

        healthBar.text.Size = ESP.settings.textSize
        healthBar.text.Center = true
        healthBar.text.Outline = true
        healthBar.text.Transparency = ESP.settings.transparency

        ESP.healthElements[player] = healthBar
    end
end

local function updateESP()
    if not ESP.enabled then
        cleanupAllESP()
        return
    end

    perf.espUpdateThrottle = perf.espUpdateThrottle + 1
    if perf.espUpdateThrottle < perf.espThrottleInterval then
        return
    end
    perf.espUpdateThrottle = 0

    local players = getPlayers() 
    local cameraPos = Camera.CFrame.Position
    local viewportSize = Camera.ViewportSize

    for _, player in ipairs(players) do
        if player == LocalPlayer then continue end

        local character = player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
        local primaryPart = character and character.PrimaryPart

        if not (character and humanoidRootPart and humanoid and humanoid.Health > 0) then
            if ESP.boxElements[player] then
                ESP.boxElements[player].Visible = false
                ESP.nameElements[player].Visible = false
                ESP.tracerElements[player].Visible = false
                local healthBar = ESP.healthElements[player]
                if healthBar then
                    healthBar.background.Visible = false
                    healthBar.fill.Visible = false
                    healthBar.outline.Visible = false
                    healthBar.text.Visible = false
                end
            end
            continue
        end

        local distance = (cameraPos - humanoidRootPart.Position).Magnitude
        if distance > ESP.maxDistance then
            if ESP.boxElements[player] then
                ESP.boxElements[player].Visible = false
                ESP.nameElements[player].Visible = false
                ESP.tracerElements[player].Visible = false
                local healthBar = ESP.healthElements[player]
                if healthBar then
                    healthBar.background.Visible = false
                    healthBar.fill.Visible = false
                    healthBar.outline.Visible = false
                    healthBar.text.Visible = false
                end
            end
            continue
        end

        local vector, onScreen = Camera:WorldToViewportPoint(humanoidRootPart.Position)

        if onScreen and vector.Z > 0 then
            createESPElement(player)

            local color = ESP.teamColor and player.TeamColor.Color or ESP.colors.box
            
            -- Calculate box size based on full character body dimensions
            local head = character:FindFirstChild("Head")
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local leftFoot = character:FindFirstChild("LeftFoot") or character:FindFirstChild("LeftLowerLeg")
            local rightFoot = character:FindFirstChild("RightFoot") or character:FindFirstChild("RightLowerLeg")
            local leftArm = character:FindFirstChild("LeftHand") or character:FindFirstChild("LeftLowerArm")
            local rightArm = character:FindFirstChild("RightHand") or character:FindFirstChild("RightLowerArm")
            
            local headPos, headOnScreen = nil, false
            local rootPos = vector
            local topY, bottomY = vector.Y, vector.Y
            local leftX, rightX = vector.X, vector.X
            
            -- Get head position (top of box)
            if head then
                headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position)
                if headOnScreen then
                    topY = headPos.Y
                end
            end
            
            -- Get bottom position (feet)
            local bottomPart = leftFoot or rightFoot or rootPart
            if bottomPart then
                local bottomPos, bottomOnScreen = Camera:WorldToViewportPoint(bottomPart.Position)
                if bottomOnScreen then
                    bottomY = bottomPos.Y
                end
            end
            
            -- Calculate width from left and right body parts
            if leftArm then
                local leftPos, leftOnScreen = Camera:WorldToViewportPoint(leftArm.Position)
                if leftOnScreen then
                    leftX = math.min(leftX, leftPos.X)
                end
            end
            
            if rightArm then
                local rightPos, rightOnScreen = Camera:WorldToViewportPoint(rightArm.Position)
                if rightOnScreen then
                    rightX = math.max(rightX, rightPos.X)
                end
            end
            
            -- Calculate box dimensions
            local height = math.abs(bottomY - topY)
            local width = math.abs(rightX - leftX)
            
            -- Ensure minimum sizes
            if height < 20 then
                height = 80 / math.max(0.1, vector.Z / 100)
            end
            if width < 20 then
                width = height * 0.5
            end
            
            -- Add padding
            height = height + 10
            width = width + 10
            
            local size = Vector2new(width, height)
            local position = Vector2new((leftX + rightX) / 2 - size.X / 2, topY - 5)

            if ESP.boxes then
                local box = ESP.boxElements[player]
                box.Size = size
                box.Position = position
                box.Color = color
                box.Visible = true
            else
                ESP.boxElements[player].Visible = false
            end

            if ESP.names then
                local name = ESP.nameElements[player]
                if ESP.showDistance then
                    name.Text = player.Name .. ' [' .. formatDistance(distance) .. 'm]'
                else
                    name.Text = player.Name
                end
                name.Position = Vector2new(vector.X, position.Y - 15)
                name.Color = ESP.colors.text
                name.Visible = true
            else
                ESP.nameElements[player].Visible = false
            end

            if ESP.tracers then
                local tracer = ESP.tracerElements[player]
                tracer.From = Vector2new(viewportSize.X/2, viewportSize.Y)
                tracer.To = Vector2new(vector.X, vector.Y)
                tracer.Color = color
                tracer.Visible = true
            else
                ESP.tracerElements[player].Visible = false
            end

            if ESP.health then
                local healthPercent = humanoid.Health / humanoid.MaxHealth
                local healthBar = ESP.healthElements[player]
                local barWidth = 4

                healthBar.background.Size = Vector2new(barWidth, size.Y)
                healthBar.background.Position = Vector2new(position.X - barWidth - 2, position.Y)
                healthBar.background.Visible = true

                healthBar.fill.Size = Vector2new(barWidth, size.Y * healthPercent)
                healthBar.fill.Position = Vector2new(position.X - barWidth - 2, position.Y + size.Y * (1 - healthPercent))
                healthBar.fill.Color = Color3new(1 - healthPercent, healthPercent, 0)
                healthBar.fill.Visible = true

                healthBar.outline.Size = Vector2new(barWidth, size.Y)
                healthBar.outline.Position = Vector2new(position.X - barWidth - 2, position.Y)
                healthBar.outline.Visible = true

                if ESP.showHealthNumber then
                    healthBar.text.Text = mathfloor(humanoid.Health)
                    healthBar.text.Position = Vector2new(position.X - barWidth - 2, position.Y - 15)
                    healthBar.text.Color = Color3new(1 - healthPercent, healthPercent, 0)
                    healthBar.text.Visible = true
                else
                    healthBar.text.Visible = false
                end
            else
                local healthBar = ESP.healthElements[player]
                healthBar.background.Visible = false
                healthBar.fill.Visible = false
                healthBar.outline.Visible = false
                healthBar.text.Visible = false
            end
        else
            if ESP.boxElements[player] then
                ESP.boxElements[player].Visible = false
                ESP.nameElements[player].Visible = false
                ESP.tracerElements[player].Visible = false
                local healthBar = ESP.healthElements[player]
                healthBar.background.Visible = false
                healthBar.fill.Visible = false
                healthBar.outline.Visible = false
                healthBar.text.Visible = false
            end
        end
    end
end

local function CheckTeam(player)
    if not Settings.MobileAimbot.teamCheck then return false end

    local playerTeam = player.Team and player.Team.Name or ""
    local myTeam = LocalPlayer.Team and LocalPlayer.Team.Name or ""

    local playerInGroup1 = table.find(classDAndChaosInsurgency, playerTeam) ~= nil
    local meInGroup1 = table.find(classDAndChaosInsurgency, myTeam) ~= nil

    local playerInGroup2 = table.find(otherTeams, playerTeam) ~= nil
    local meInGroup2 = table.find(otherTeams, myTeam) ~= nil

    if (playerInGroup1 and meInGroup1) or (playerInGroup2 and meInGroup2) then
    return true
end

    return false
end

local function HasWeapon()
    local Char = LocalPlayer.Character
    if not Char then return false end

    local Tool = Char:FindFirstChildOfClass("Tool")
    if not Tool then return false end

    if Tool:FindFirstChild("Ammo") or Tool:FindFirstChild("GunScript") then
        return true
    end

    local toolLower = Tool.Name:lower()
    local weaponPatterns = {
        "gun", "pistol", "rifle", "weapon", "ak", "m4", "sniper", "shotgun", "smg"
    }

    for _, word in ipairs(weaponPatterns) do
        if string.find(toolLower, word) then
                return true
        end
        end

            return false
        end

local function CanSee(part)
    if not part or not part:IsA("BasePart") then
        return false
    end
    
    local character = LocalPlayer.Character
    if not character then return false end
    
    local head = character:FindFirstChild("Head")
    if not head then return false end

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = { character, Camera }

    local origin = Camera.CFrame.Position
    local targetPos = part.Position
    local direction = targetPos - origin
            local magnitude = direction.Magnitude
    
    if magnitude <= 0 then return false end
    
                local result = workspace:Raycast(origin, direction, params)
    
                if not result then
            return true
        end
    
    local hitInstance = result.Instance
    
                if hitInstance and part.Parent and hitInstance:IsDescendantOf(part.Parent) then
            return true
        end

    if hitInstance then
                    pcall(function()
            if hitInstance.Transparency and hitInstance.Transparency >= 0.9 then
                return true
            end
            
            if hitInstance.Material == Enum.Material.Glass or 
               hitInstance.Material == Enum.Material.ForceField or
               hitInstance.Material == Enum.Material.Neon then
                return true
            end
            
            if hitInstance.CanCollide == false then
                return true
            end
        end)
    end
    
    return false
end

local function CanSeeMobile(part)
    if not part or not part:IsA("BasePart") then
        return false
    end
    
    local character = LocalPlayer.Character
    if not character then return false end
    
    local head = character:FindFirstChild("Head")
    if not head then return false end
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = { character, Camera }
    
    local origin = Camera.CFrame.Position
    local targetPos = part.Position
    local direction = targetPos - origin
    local magnitude = direction.Magnitude
    
    if magnitude <= 0 then return false end
    
    local result = workspace:Raycast(origin, direction, params)
    
    if not result then
        return true
    end
    
    local hitInstance = result.Instance
    
    if hitInstance and part.Parent and hitInstance:IsDescendantOf(part.Parent) then
        return true
    end
    
    if hitInstance then
        pcall(function()
            if hitInstance.Transparency and hitInstance.Transparency >= 0.8 then
                return true
            end
            
            if hitInstance.Material == Enum.Material.Glass or 
               hitInstance.Material == Enum.Material.ForceField or
               hitInstance.Material == Enum.Material.Neon then
                return true
            end
            
            if hitInstance.CanCollide == false then
                return true
            end
        end)
    end
    
    return false
end

local function FindBestTargetPartMobile(character)
    if not character then return nil end

    local bodyPartGroups = {

        {
            character:FindFirstChild("Head")
        },

        {
            character:FindFirstChild("Torso"),
            character:FindFirstChild("UpperTorso"),
            character:FindFirstChild("LeftUpperArm"),
            character:FindFirstChild("RightUpperArm"),
            character:FindFirstChild("LeftLowerArm"),
            character:FindFirstChild("RightLowerArm"),
            character:FindFirstChild("LeftHand"),
            character:FindFirstChild("RightHand")
        },

        {
            character:FindFirstChild("HumanoidRootPart"),
            character:FindFirstChild("LowerTorso"),
            character:FindFirstChild("LeftUpperLeg"),
            character:FindFirstChild("RightUpperLeg")
        },

        {
            character:FindFirstChild("LeftLowerLeg"),
            character:FindFirstChild("RightLowerLeg"),
            character:FindFirstChild("LeftFoot"),
            character:FindFirstChild("RightFoot")
        }
    }
    
    for groupIndex, group in ipairs(bodyPartGroups) do
        for _, part in ipairs(group) do
            if part and part:IsA("BasePart") then

                if not Settings.MobileAimbot.wallCheck or CanSeeMobile(part) then
                    return part
                end
            end
        end
    end

    for _, descendant in ipairs(character:GetDescendants()) do
        if descendant:IsA("BasePart") then
            local parentIsAccessory = descendant.Parent and descendant.Parent:IsA("Accessory")
            if not parentIsAccessory then
                if not Settings.MobileAimbot.wallCheck or CanSeeMobile(descendant) then
                    return descendant
                end
            end
        end
    end
    return nil
end

local lastTargetPart = {}
local lastSwitchTime = 0

local function GetDynamicTargetPart(character, isMobile)
    if not character then return nil end
    
    local currentTime = tick()
    local head = character:FindFirstChild("Head")
    local canSeeHead = false
    
    if head and head:IsA("BasePart") then
        canSeeHead = not Settings.MobileAimbot.wallCheck or CanSeeMobile(head)
    end
    
    local cooldown = 0.1
    if canSeeHead and (currentTime - lastSwitchTime) > cooldown then
        lastTargetPart[character] = head
        lastSwitchTime = currentTime
        return head
    end
    
    if lastTargetPart[character] and lastTargetPart[character].Parent == character then
        local part = lastTargetPart[character]
        if part:IsA("BasePart") then
            local canSeePart = not Settings.MobileAimbot.wallCheck or CanSeeMobile(part)
            
            if canSeePart then
                return part
            end
        end
    end
    
    local newTarget = FindBestTargetPartMobile(character)
    
    if newTarget then
        lastTargetPart[character] = newTarget
    end
    
    return newTarget
end

local function CheckHeadVisibilityMobile(character)
    if not character then return nil end

    local head = character:FindFirstChild("Head")
    if head and head:IsA("BasePart") and (not Settings.MobileAimbot.wallCheck or CanSeeMobile(head)) then
        return head
    end

    return nil
end

local function GetClosestPlayerInMobileFOV()
    local closest = nil
    local shortestDistanceToCenter = math.huge
    local screenCenter = Camera.ViewportSize / 2

    for _, plr in ipairs(getPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local hrpTarget = plr.Character.HumanoidRootPart
            local humanoid = plr.Character:FindFirstChild("Humanoid")
            
            if not humanoid or humanoid.Health <= 0 then
                continue
            end

            if CheckTeam(plr) then
                continue
            end

            if Settings.MobileAimbot.wallCheck then
                local head = plr.Character:FindFirstChild("Head")
                if head and not CanSeeMobile(head) then
                    continue
                end
            end

            local worldPos, onScreen = Camera:WorldToViewportPoint(hrpTarget.Position)

            if onScreen then
                local distanceFromCenter = (Vector2.new(worldPos.X, worldPos.Y) - Vector2.new(screenCenter.X, screenCenter.Y)).Magnitude

                if distanceFromCenter <= mobileFovRadius then

                    if distanceFromCenter < shortestDistanceToCenter then
                        shortestDistanceToCenter = distanceFromCenter
                        closest = plr
                    end
                end
            end
        end
    end

    return closest
end

local function startMobileAimbot()
    if mobileAimbotConnection then return end

    mobileAimbotConnection = RunService.RenderStepped:Connect(function()
        if Settings.MobileAimbot.requireGunEquipped and not HasWeapon() then
            return
        end

        local target = GetClosestPlayerInMobileFOV()
        if target and target.Character then
            local targetPart = GetDynamicTargetPart(target.Character, true)

            if targetPart then
                local targetPos = targetPart.Position
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPos)
            end
        end
    end)
end

local function stopMobileAimbot()
    if mobileAimbotConnection then
        mobileAimbotConnection:Disconnect()
        mobileAimbotConnection = nil
    end
end

local function createMobileFovCircle()
    if mobileFovCircle then return end

    mobileFovCircle = Drawing.new("Circle")
    mobileFovCircle.Thickness = 2
    mobileFovCircle.NumSides = 100
    mobileFovCircle.Radius = mobileFovRadius
    mobileFovCircle.Filled = false
    mobileFovCircle.Color = Color3.fromRGB(0, 170, 255)
    mobileFovCircle.Visible = true

    RunService.RenderStepped:Connect(function()
        if mobileFovCircle then
            local screenCenter = Camera.ViewportSize / 2
            mobileFovCircle.Position = Vector2.new(screenCenter.X, screenCenter.Y)
            mobileFovCircle.Radius = mobileFovRadius

            if mobileRainbowEnabled then
                mobileHue = (mobileHue + 1) % 360
                mobileFovCircle.Color = Color3.fromHSV(mobileHue/360, 1, 1)
            end
        end
    end)
end

local function destroyMobileFovCircle()
    if mobileFovCircle then
        mobileFovCircle:Remove()
        mobileFovCircle = nil
    end
end

local Window = Rayfield:CreateWindow({
   Name = "SCP: Roleplay ( discord.gg/TD8xjkF6WK )",
   Icon = "user",
   LoadingTitle = "Loading...",
   LoadingSubtitle = "by CrystalCystales",
Theme = {
    Shadow = Color3.fromRGB(8, 12, 20),
    SliderProgress = Color3.fromRGB(100, 150, 255), 
    PlaceholderColor = Color3.fromRGB(120, 130, 150), 
    InputStroke = Color3.fromRGB(50, 70, 90), 
    ToggleDisabledStroke = Color3.fromRGB(60, 80, 100),
    InputBackground = Color3.fromRGB(18, 20, 25),
    ElementBackgroundHover = Color3.fromRGB(25, 30, 40), 
    DropdownUnselected = Color3.fromRGB(30, 35, 45),
    SelectedTabTextColor = Color3.fromRGB(150, 200, 255), 
    NotificationBackground = Color3.fromRGB(12, 15, 20),
    DropdownSelected = Color3.fromRGB(40, 50, 65),
    SecondaryElementStroke = Color3.fromRGB(70, 90, 120),
    Background = Color3.fromRGB(10, 12, 18),
    ToggleDisabledOuterStroke = Color3.fromRGB(55, 70, 90),
    TabStroke = Color3.fromRGB(80, 100, 130),
    ElementBackground = Color3.fromRGB(22, 26, 35),
    ToggleEnabledOuterStroke = Color3.fromRGB(120, 180, 255), 
    ToggleEnabled = Color3.fromRGB(100, 150, 255),
    ToggleEnabledStroke = Color3.fromRGB(80, 130, 220),
    ToggleDisabled = Color3.fromRGB(90, 110, 130),
    SecondaryElementBackground = Color3.fromRGB(20, 24, 32),
    ToggleBackground = Color3.fromRGB(15, 18, 25),
    TabTextColor = Color3.fromRGB(200, 220, 255),
    ElementStroke = Color3.fromRGB(80, 100, 130),
    SliderBackground = Color3.fromRGB(20, 24, 32),
    SliderStroke = Color3.fromRGB(120, 160, 220),
    NotificationActionsBackground = Color3.fromRGB(25, 30, 40),
    Topbar = Color3.fromRGB(12, 15, 22),
    TabBackground = Color3.fromRGB(25, 30, 40), 
    TabBackgroundSelected = Color3.fromRGB(100, 150, 255), 
    TextColor = Color3.fromRGB(220, 230, 255), 
},
   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false,
   Discord = {
      Enabled = false,
      Invite = "noinvitelink",
      RememberJoins = true
   },
   KeySystem = true,
   KeySettings = {
   Title = "Key System",
   Subtitle = "discord.gg/TD8xjkF6WK",
   Note = "The link has been automatically copied to clipboard.",
   FileName = "Key",
   SaveKey = false,
   GrabKeyFromSite = false,
   Key = "nissan23"
}
})

local IntroductionTab = Window:CreateTab("Introduction","magnet") 

IntroductionTab:CreateParagraph({
    Title = "Welcome to Our Script",
    Content = "Thank you for using our script! This tool provides various exploiting features to make your game experience better."
})

IntroductionTab:CreateButton({
    Name = "Join Our Discord - Click to Copy the invite",
    Callback = function()
        setclipboard("https://discord.gg/TD8xjkF6WK")
    end
})

IntroductionTab:CreateButton({
    Name = "FPS Boost / Low Graphics",
    Info = "Lowers game quality to boost FPS significantly",
    Callback = function()
        pcall(function()
            local Terrain = workspace:FindFirstChildWhichIsA("Terrain")
            if Terrain then
                Terrain.WaterWaveSize = 0
                Terrain.WaterWaveSpeed = 0
                Terrain.WaterReflectance = 0
                Terrain.WaterTransparency = 1
            end
            
            Lighting.GlobalShadows = false
            Lighting.FogEnd = 9e9
            Lighting.FogStart = 9e9
            settings().Rendering.QualityLevel = 1
            
            for _, v in pairs(game:GetDescendants()) do
                pcall(function()
                    if v:IsA("BasePart") then
                        v.CastShadow = false
                        v.Material = "Plastic"
                        v.Reflectance = 0
                        v.BackSurface = "SmoothNoOutlines"
                        v.BottomSurface = "SmoothNoOutlines"
                        v.FrontSurface = "SmoothNoOutlines"
                        v.LeftSurface = "SmoothNoOutlines"
                        v.RightSurface = "SmoothNoOutlines"
                        v.TopSurface = "SmoothNoOutlines"
                    elseif v:IsA("Decal") then
                        v.Transparency = 1
                        v.Texture = ""
                    elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
                        v.Lifetime = NumberRange.new(0)
                    end
                end)
            end
            
            for _, v in pairs(Lighting:GetDescendants()) do
                pcall(function()
                    if v:IsA("PostEffect") then
                        v.Enabled = false
                    end
                end)
            end
            
            workspace.DescendantAdded:Connect(function(child)
                task.spawn(function()
                    pcall(function()
                        if child:IsA("ForceField") or child:IsA("Sparkles") or child:IsA("Smoke") or child:IsA("Fire") or child:IsA("Beam") then
                            RunService.Heartbeat:Wait()
                            child:Destroy()
                        elseif child:IsA("BasePart") then
                            child.CastShadow = false
                        end
                    end)
                end)
            end)
            
            Rayfield:Notify({
                Title = "FPS Boost Applied",
                Content = "Graphics quality has been lowered to boost FPS!",
                Duration = 3,
                Image = "settings"
            })
        end)
    end
})

IntroductionTab:CreateParagraph({
    Title = "Updates & Support",
    Content = "Join our Discord community for script updates, support, and to connect with other users. Click the button above to copy our Discord invite link to your clipboard."
})

IntroductionTab:CreateParagraph({
    Title = "Credits",
    Content = 
        "Script created by Bodzio.\n" ..
        "This script uses the Rayfield library variant developed by Axleoislost.\n" ..
        "Special thanks to the Overhaul members for their invaluable support with Moderator Tracking and game vulnerability research."
})

local MainTab = Window:CreateTab("ESP","eye")
local SettingsTab = Window:CreateTab("ESP Settings","settings-2")

ESPMasterToggle = MainTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = Settings.ESP.enabled,
    Flag = "MasterToggle",
    Callback = function(Value)
        Settings.ESP.enabled = Value
        ESP.enabled = Value
        if not Value then
            cleanupAllESP()
        end
    end
})
registerUIElement("ESPMasterToggle", ESPMasterToggle)

BoxesToggle = MainTab:CreateToggle({
    Name = "Boxes",
    CurrentValue = Settings.ESP.boxes,
    Callback = function(Value) 
        Settings.ESP.boxes = Value
        ESP.boxes = Value 
    end
})
registerUIElement("Boxes", BoxesToggle)

NamesToggle = MainTab:CreateToggle({
    Name = "Names",
    CurrentValue = Settings.ESP.names,
    Callback = function(Value) 
        Settings.ESP.names = Value
        ESP.names = Value 
    end
})
registerUIElement("Names", NamesToggle)

TracersToggle = MainTab:CreateToggle({
    Name = "Tracers",
    CurrentValue = Settings.ESP.tracers,
    Callback = function(Value) 
        Settings.ESP.tracers = Value
        ESP.tracers = Value 
    end
})
registerUIElement("Tracers", TracersToggle)

HealthBarsToggle = MainTab:CreateToggle({
    Name = "Health Bars",
    CurrentValue = Settings.ESP.health,
    Callback = function(Value) 
        Settings.ESP.health = Value
        ESP.health = Value 
    end
})
registerUIElement("HealthBars", HealthBarsToggle)

ShowHealthNumberToggle = MainTab:CreateToggle({
    Name = "Show Health Number",
    CurrentValue = Settings.ESP.showHealthNumber,
    Callback = function(Value) 
        Settings.ESP.showHealthNumber = Value
        ESP.showHealthNumber = Value 
    end
})
registerUIElement("ShowHealthNumber", ShowHealthNumberToggle)

ShowDistanceToggle = MainTab:CreateToggle({
    Name = "Show Distance",
    CurrentValue = Settings.ESP.showDistance,
    Callback = function(Value) 
        Settings.ESP.showDistance = Value
        ESP.showDistance = Value 
    end
})
registerUIElement("ShowDistance", ShowDistanceToggle)

TeamColorsToggle = MainTab:CreateToggle({
    Name = "Team Colors",
    CurrentValue = Settings.ESP.teamColor,
    Callback = function(Value) 
        Settings.ESP.teamColor = Value
        ESP.teamColor = Value 
    end
})
registerUIElement("TeamColors", TeamColorsToggle)

local ModESPConnection = nil

local function UpdateModESP()
    if ModESPConnection then
        ModESPConnection:Disconnect()
        ModESPConnection = nil
    end

    ModESPConnection = RunService.Heartbeat:Connect(function()
        pcall(function()
            for _, player in ipairs(getPlayers()) do
                if player:GetRankInGroup(5479038) >= 248 and player.Character then
                    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                    if hrp and not player.Character:FindFirstChild("ModeratorBillboard") then
                        local billboard = Instance.new("BillboardGui")
                        billboard.Name = "ModeratorBillboard"
                        billboard.Adornee = hrp
                        billboard.Size = UDim2.new(10, 0, 4, 0)
                        billboard.StudsOffset = Vector3.new(0, 5, 0)
                        billboard.AlwaysOnTop = true
                        billboard.Parent = player.Character

                        local textLabel = Instance.new("TextLabel")
                        textLabel.Parent = billboard
                        textLabel.Size = UDim2.new(1, 0, 1, 0)
                        textLabel.BackgroundTransparency = 1
                        textLabel.Text = "MODERATOR HERE"
                        textLabel.TextColor3 = Color3.new(1, 0, 0)
                        textLabel.TextScaled = false
                        textLabel.Font = Enum.Font.SourceSansBold
                        textLabel.TextSize = 35
                    end

                    for _, part in ipairs(player.Character:GetChildren()) do
                        if part:IsA("BasePart") and not part:FindFirstChild("ModBox") then
                            local box = Instance.new("BoxHandleAdornment")
                            box.Name = "ModBox"
                            box.Size = part.Size + Vector3.new(0.1, 0.1, 0.1)
                            box.Adornee = part
                            box.Color3 = Color3.new(1, 0, 0)
                            box.Transparency = 0
                            box.AlwaysOnTop = true
                            box.ZIndex = 10
                            box.Parent = part
                        end
                    end
                end
            end
        end)
    end)
end

local function ClearModESP()
    if ModESPConnection then
        ModESPConnection:Disconnect()
        ModESPConnection = nil
    end

    for _, player in ipairs(getPlayers()) do
        if player.Character then
            local bb = player.Character:FindFirstChild("ModeratorBillboard")
            if bb then bb:Destroy() end

            for _, part in ipairs(player.Character:GetChildren()) do
                if part:IsA("BasePart") then
                    local box = part:FindFirstChild("ModBox")
                    if box then box:Destroy() end
                end
            end
        end
    end
end

local Toggle = MainTab:CreateToggle({
    Name = "Toggle Moderator ESP",
    CurrentValue = true,
    Flag = "ModESPToggle",
    Callback = function(Value)
        if Value then
            UpdateModESP()
        else
            ClearModESP()
        end
    end,
})

task.spawn(function()
    local maxWaitTime = 5
    local startTime = tick()

    while not (MainTab.Flags and MainTab.Flags.ModESPToggle ~= nil) do
        if tick() - startTime > maxWaitTime then
            UpdateModESP()
            return
        end
        task.wait()
    end

    if MainTab.Flags.ModESPToggle then
        UpdateModESP()
    end
end)

task.spawn(function()
    task.wait(1)
    if Toggle.CurrentValue and not ModESPConnection then
        UpdateModESP()
    end
end)

TextSizeSlider = SettingsTab:CreateSlider({
    Name = "Text Size",
    Range = {8, 24},
    Increment = 0.1,
    Suffix = "px",
    CurrentValue = Settings.ESP.textSize,
    Callback = function(Value)
        Settings.ESP.textSize = Value
        ESP.settings.textSize = Value
        for _, player in ipairs(getPlayers()) do
            if ESP.nameElements[player] then
                ESP.nameElements[player].Size = Value
            end
            if ESP.healthElements[player] then
                ESP.healthElements[player].text.Size = Value
            end
        end
    end
})
registerUIElement("TextSizeSlider", TextSizeSlider)

BoxThicknessSlider = SettingsTab:CreateSlider({
    Name = "Box Thickness",
    Range = {1, 5},
    Increment = 0.1,
    Suffix = "px",
    CurrentValue = Settings.ESP.boxThickness,
    Callback = function(Value)
        Settings.ESP.boxThickness = Value
        ESP.settings.boxThickness = Value
        for _, player in ipairs(getPlayers()) do
            if ESP.boxElements[player] then
                ESP.boxElements[player].Thickness = Value
            end
        end
    end
})
registerUIElement("BoxThicknessSlider", BoxThicknessSlider)

TracerThicknessSlider = SettingsTab:CreateSlider({
    Name = "Tracer Thickness",
    Range = {1, 5},
    Increment = 0.1,
    Suffix = "px",
    CurrentValue = Settings.ESP.tracerThickness,
    Callback = function(Value)
        Settings.ESP.tracerThickness = Value
        ESP.settings.tracerThickness = Value
        for _, player in ipairs(getPlayers()) do
            if ESP.tracerElements[player] then
                ESP.tracerElements[player].Thickness = Value
            end
        end
    end
})
registerUIElement("TracerThicknessSlider", TracerThicknessSlider)

ESPTransparencySlider = SettingsTab:CreateSlider({
    Name = "ESP Transparency",
    Range = {0, 1},
    Increment = 0.01,
    Suffix = "%",
    CurrentValue = 1,
    Callback = function(Value)
        ESP.settings.transparency = Value
        for _, player in ipairs(getPlayers()) do
            if ESP.boxElements[player] then
                ESP.boxElements[player].Transparency = Value
                ESP.nameElements[player].Transparency = Value
                ESP.tracerElements[player].Transparency = Value

                local healthBar = ESP.healthElements[player]
                healthBar.background.Transparency = Value
                healthBar.fill.Transparency = Value
                healthBar.outline.Transparency = Value
                healthBar.text.Transparency = Value
            end
        end
    end
})
registerUIElement("ESPTransparencySlider", ESPTransparencySlider)

MaxDistanceSlider = SettingsTab:CreateSlider({
    Name = "Max Distance",
    Range = {100, 50000},
    Increment = 10,
    Suffix = "m",
    CurrentValue = 5000,
    Callback = function(Value)
        ESP.maxDistance = Value
    end
})
registerUIElement("MaxDistanceSlider", MaxDistanceSlider)

ESPFPSSlider = SettingsTab:CreateSlider({
    Name = "ESP FPS",
    Range = {10, 120},
    Increment = 1,
    Suffix = " FPS",
    CurrentValue = Settings.ESP.espFPS,
    Callback = function(Value)
        Settings.ESP.espFPS = Value
        perf.espFPS = Value
        perf.espThrottleInterval = math.floor(60 / perf.espFPS)
        if perf.espThrottleInterval < 1 then
            perf.espThrottleInterval = 1
        end
    end
})
registerUIElement("ESPFPSSlider", ESPFPSSlider)

SettingsTab:CreateParagraph({
    Title = "ESP FPS Control",
    Content = "Higher FPS = smoother ESP but more CPU usage\nLower FPS = less CPU usage but choppier ESP\nDefault: 60 FPS (recommended)"
})

ESPColorPicker = SettingsTab:CreateColorPicker({
    Name = "ESP Color",
    Color = Settings.ESP.boxColor,
    Callback = function(Value)
        Settings.ESP.boxColor = Value
        Settings.ESP.tracerColor = Value
        ESP.colors.box = Value
        ESP.colors.tracer = Value
        for _, player in ipairs(getPlayers()) do
            if not ESP.teamColor and ESP.boxElements[player] then
                ESP.boxElements[player].Color = Value
                ESP.tracerElements[player].Color = Value
            end
        end
    end
})
registerUIElement("ESPColorPicker", ESPColorPicker)

TextColorPicker = SettingsTab:CreateColorPicker({
    Name = "Text Color",
    Color = Settings.ESP.textColor,
    Callback = function(Value)
        Settings.ESP.textColor = Value
        ESP.colors.text = Value
        for _, player in ipairs(getPlayers()) do
            if ESP.nameElements[player] then
                ESP.nameElements[player].Color = Value
            end
        end
    end
})
registerUIElement("TextColorPicker", TextColorPicker)

local AimbotTab = Window:CreateTab("Aimbot", "crosshair")

AimbotTab:CreateSection("Main Options")

local AimbotFOV = Settings.Aimbot.fov
local defaultCameraFOV = Camera.FieldOfView
local selectedPart = Settings.Aimbot.targetPart
local aimbotTarget = nil
local aimbotConnection = nil

local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 2
FOVCircle.NumSides = 100
FOVCircle.Filled = false
FOVCircle.Color = Color3.fromRGB(255, 255, 255)
FOVCircle.Visible = Settings.Aimbot.showFOV

local function getPartSafe(char, name)
    if not char then return nil end
    if name == "Torso" then name = "UpperTorso" end
    local p = char:FindFirstChild(name)
    if not p then
        if name == "Neck" then return char:FindFirstChild("Head") end
        return nil 
    end
    if p:IsA("Accessory") then
        return p:FindFirstChild("Handle")
    elseif p:IsA("BasePart") then
        return p
    end
    return nil
end

local function ValidateTarget(lp, tp)
    local tch = tp.Character
    if not tch then return false end
    if Settings.Aimbot.forcefieldCheck and tch:FindFirstChildOfClass("ForceField") then return false end
    local hum = tch:FindFirstChildOfClass("Humanoid")
    if not hum or (Settings.Aimbot.deathCheck and hum.Health <= 0) then return false end
    
    local lt = lp.Team and lp.Team.Name or ""
    local tt = tp.Team and tp.Team.Name or ""
    
    if not Settings.Aimbot.teamCheck then
        return true
    end
    
    local hostile = {}
    if lt == "Class - D" or lt == "Chaos Insurgency" then
        hostile = {
            ["Security Department"]=true,["Mobile Task Force"]=true,
            ["Internal Security Department"]=true,["Rapid Response Team"]=true,
            ["Scientific Department"]=true,["Medical Department"]=true,
            ["Administrative Department"]=true,["Intelligence Agency"]=true,
        }
    else
        hostile = { ["Class - D"]=true, ["Chaos Insurgency"]=true }
    end
    return hostile[tt] or false
end

local LOS_PARAMS = RaycastParams.new()
LOS_PARAMS.FilterType = Enum.RaycastFilterType.Blacklist

local function PerformLineOfSightCheck(target)
    if not Settings.Aimbot.wallCheck then return true end
    local origin = getPartSafe(LocalPlayer.Character, "Head")
    if not origin then return false end

    LOS_PARAMS.FilterDescendantsInstances = {LocalPlayer.Character}

    local char = target
    if target:IsA("Player") then char = target.Character end
    if not char then return false end

    local checkParts = {"Head", "UpperTorso", "Torso", "HumanoidRootPart"}
    
    for _, name in ipairs(checkParts) do
        local part = char:FindFirstChild(name)
        if part and part:IsA("BasePart") then
            local ray = workspace:Raycast(origin.Position, part.Position - origin.Position, LOS_PARAMS)
            if not ray or ray.Instance == part or ray.Instance.Name == "Handle" or ray.Instance:IsDescendantOf(char) then
                return true
            end
        end
    end

    local part = char.PrimaryPart or char:FindFirstChild("HumanoidRootPart")
    if not part then
         for _, ch in ipairs(char:GetChildren()) do
             if ch:IsA("BasePart") then part = ch break end
         end
    end
    
    if part then
        local ray = workspace:Raycast(origin.Position, part.Position - origin.Position, LOS_PARAMS)
        if not ray or ray.Instance == part or ray.Instance.Name == "Handle" or ray.Instance:IsDescendantOf(char) then
            return true
        end
    end

    return false
end

local function GetClosestPlayerInFOV()
    local character = LocalPlayer.Character
    if not character then return nil end
    
    local head = character:FindFirstChild("Head")
    if not head then return nil end
    
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local currentCameraFOV = Camera.FieldOfView
    local fovScale = currentCameraFOV / (defaultCameraFOV or 70)
    local fovRadius = (AimbotFOV or 65) * 5 * fovScale
    
    local closest, closestDistance = nil, math.huge
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if not ValidateTarget(LocalPlayer, player) then continue end
        
        local targetChar = player.Character
        if not targetChar then continue end
        
        local targetPart = getPartSafe(targetChar, selectedPart) or targetChar:FindFirstChild("Head")
        if not targetPart then continue end
        
        if Settings.Aimbot.wallCheck and not PerformLineOfSightCheck(player) then continue end
        
        local position, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        if not onScreen then continue end
        
        local screenPoint = Vector2.new(position.X, position.Y)
        local distance = (center - screenPoint).Magnitude
        
        if distance <= fovRadius and distance < closestDistance then
            closest = player
            closestDistance = distance
        end
    end
    
    return closest
end

local function StartAimbot()
    if aimbotConnection then return end
    
    aimbotConnection = RunService.RenderStepped:Connect(function()
        if not Settings.Aimbot.enabled then
            aimbotTarget = nil
            return
        end
        
        local char = LocalPlayer.Character
        if not char then
            aimbotTarget = nil
            return
        end
        
        if Settings.Aimbot.requireGunEquipped then
            if not char:FindFirstChildOfClass("Tool") then
                aimbotTarget = nil
                return
            end
        end
        
        -- Always re-evaluate target every frame to allow switching
        local newTarget = GetClosestPlayerInFOV()
        
        -- Clear old target if it's no longer valid
        if aimbotTarget then
            local oldTargetChar = aimbotTarget.Character
            if not oldTargetChar then
                aimbotTarget = nil
            elseif oldTargetChar ~= newTarget.Character then
                -- Target changed, allow switch
                aimbotTarget = nil
            end
        end
        
        -- Update to new target
        aimbotTarget = newTarget
        
        if aimbotTarget then
            local targetChar = aimbotTarget.Character
            if not targetChar then
                aimbotTarget = nil
                return
            end
            
            local targetPart = getPartSafe(targetChar, selectedPart) or targetChar:FindFirstChild("Head")
            if not targetPart then
                aimbotTarget = nil
                return
            end
            
            -- Verify target is still in FOV and valid
            local position, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if not onScreen then
                aimbotTarget = nil
                return
            end
            
            local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            local screenPoint = Vector2.new(position.X, position.Y)
            local currentCameraFOV = Camera.FieldOfView
            local fovScale = currentCameraFOV / (defaultCameraFOV or 70)
            local fovRadius = (AimbotFOV or 65) * 5 * fovScale
            local distance = (center - screenPoint).Magnitude
            
            -- Only aim if target is still within FOV
            if distance <= fovRadius then
                local camera = workspace.CurrentCamera
                local targetPosition = targetPart.Position
                local cameraPosition = camera.CFrame.Position
                
                camera.CFrame = CFrame.new(cameraPosition, targetPosition)
            else
                -- Target moved out of FOV, clear it
                aimbotTarget = nil
            end
        end
    end)
end

local function StopAimbot()
    if aimbotConnection then
        aimbotConnection:Disconnect()
        aimbotConnection = nil
    end
    aimbotTarget = nil
end

RunService.RenderStepped:Connect(function()
    if FOVCircle then
        local screenCenter = Camera.ViewportSize / 2
        FOVCircle.Position = Vector2.new(screenCenter.X, screenCenter.Y)
        
        local currentCameraFOV = Camera.FieldOfView
        local fovScale = currentCameraFOV / (defaultCameraFOV or 70)
        local fovRadius = (AimbotFOV or 65) * 5 * fovScale
        
        FOVCircle.Radius = fovRadius
        FOVCircle.Visible = Settings.Aimbot.showFOV
    end
end)

AimbotToggle = AimbotTab:CreateToggle({
    Name = "Enable Aimbot",
    CurrentValue = Settings.Aimbot.enabled,
    Callback = function(Value)
        Settings.Aimbot.enabled = Value
        if Value then
            StartAimbot()
        else
            StopAimbot()
        end
    end,
})
registerUIElement("AimbotToggle", AimbotToggle)
table.insert(allToggles, AimbotToggle)

AimbotFOVSlider = AimbotTab:CreateSlider({
    Name = "Aimbot FOV",
    Range = {10, 200},
    Increment = 1,
    Suffix = "",
    CurrentValue = Settings.Aimbot.fov,
    Callback = function(Value)
        Settings.Aimbot.fov = Value
        AimbotFOV = Value
    end,
})
registerUIElement("AimbotFOVSlider", AimbotFOVSlider)

ShowFOVToggle = AimbotTab:CreateToggle({
    Name = "Show FOV Circle",
    CurrentValue = Settings.Aimbot.showFOV,
    Callback = function(Value)
        Settings.Aimbot.showFOV = Value
        FOVCircle.Visible = Value
    end,
})
registerUIElement("ShowFOVToggle", ShowFOVToggle)
table.insert(allToggles, ShowFOVToggle)

AimbotTargetPartDropdown = AimbotTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "UpperTorso", "HumanoidRootPart"},
    CurrentOption = Settings.Aimbot.targetPart,
    Callback = function(Value)
        Settings.Aimbot.targetPart = Value
        selectedPart = Value
    end,
})
registerUIElement("AimbotTargetPartDropdown", AimbotTargetPartDropdown)

AimbotTab:CreateSection("Targeting Options")

AimbotTeamCheck = AimbotTab:CreateToggle({
    Name = "Team Check",
    CurrentValue = Settings.Aimbot.teamCheck,
    Callback = function(Value)
        Settings.Aimbot.teamCheck = Value
    end,
})
registerUIElement("AimbotTeamCheck", AimbotTeamCheck)
table.insert(allToggles, AimbotTeamCheck)

AimbotGunCheck = AimbotTab:CreateToggle({
    Name = "Require Gun Equipped",
    CurrentValue = Settings.Aimbot.requireGunEquipped,
    Callback = function(Value)
        Settings.Aimbot.requireGunEquipped = Value
    end,
})
registerUIElement("AimbotGunCheck", AimbotGunCheck)
table.insert(allToggles, AimbotGunCheck)

AimbotWallCheck = AimbotTab:CreateToggle({
    Name = "Wall Check",
    CurrentValue = Settings.Aimbot.wallCheck,
    Callback = function(Value)
        Settings.Aimbot.wallCheck = Value
    end,
})
registerUIElement("AimbotWallCheck", AimbotWallCheck)
table.insert(allToggles, AimbotWallCheck)

AimbotDeathCheck = AimbotTab:CreateToggle({
    Name = "Death Check",
    CurrentValue = Settings.Aimbot.deathCheck,
    Callback = function(Value)
        Settings.Aimbot.deathCheck = Value
    end,
})
registerUIElement("AimbotDeathCheck", AimbotDeathCheck)
table.insert(allToggles, AimbotDeathCheck)

AimbotForcefieldCheck = AimbotTab:CreateToggle({
    Name = "Forcefield Check",
    CurrentValue = Settings.Aimbot.forcefieldCheck,
    Callback = function(Value)
        Settings.Aimbot.forcefieldCheck = Value
    end,
})
registerUIElement("AimbotForcefieldCheck", AimbotForcefieldCheck)
table.insert(allToggles, AimbotForcefieldCheck)

local MovementTab = Window:CreateTab("Movement","activity")

local function getLocalPlayer()
    local player = game:GetService("Players").LocalPlayer
    if not player then
        game:GetService("Players"):GetPropertyChangedSignal("LocalPlayer"):Wait()
        player = game:GetService("Players").LocalPlayer
    end
    return player
end

_G.WalkSpeedValue = Settings.Movement.walkSpeedValue

SpeedToggle = MovementTab:CreateToggle({
    Name = "Walkspeed",
    CurrentValue = Settings.Movement.walkSpeedEnabled,
    Flag = "WalkSpeedToggle",
    Callback = function(Value)
        Settings.Movement.walkSpeedEnabled = Value
        _G.WalkSpeedToggle = Value
    end,
})
registerUIElement("WalkSpeedToggle", SpeedToggle)
table.insert(allToggles, SpeedToggle)

SpeedSlider2 = MovementTab:CreateSlider({
    Name = "Walkspeed Speed",
    Range = {0.01, 0.22},
    Increment = 0.01,
    Suffix = "x",
    CurrentValue = Settings.Movement.walkSpeedValue,
    Flag = "WalkSpeedSpeed",
    Callback = function(Value)
        Settings.Movement.walkSpeedValue = Value
        _G.WalkSpeedValue = Value
    end,
})
registerUIElement("WalkSpeedSpeed", SpeedSlider2)

RunService.Heartbeat:Connect(function()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end

    if _G.WalkSpeedToggle then
        local look = Vector3.new(Camera.CFrame.LookVector.X, 0, Camera.CFrame.LookVector.Z).Unit
        local right = Vector3.new(-look.Z, 0, look.X)
        local move = Vector3.zero

        if UserInputService:IsKeyDown(Enum.KeyCode.W) then move = move + look end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then move = move - look end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then move = move + right end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then move = move - right end

        if move.Magnitude > 0 then
            LocalPlayer.Character.HumanoidRootPart.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame + move.Unit * _G.WalkSpeedValue
        end
    end
end)

local Noclipping 

function NoclipLoop()
    local character = getLocalPlayer().Character
    if character then
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.CanCollide then
                part.CanCollide = false
            end
        end
    end
end

NoclipToggle = MovementTab:CreateToggle({
    Name = "Enable Noclip",
    CurrentValue = Settings.Movement.noclipEnabled,
    Flag = "NoclipToggle",
    Callback = function(Value)
        Settings.Movement.noclipEnabled = Value
        if Value then
            if not Noclipping then
                Noclipping = RunService.Stepped:Connect(NoclipLoop)
            end
        else
            if Noclipping then
                Noclipping:Disconnect()
                Noclipping = nil
            end

            local character = getLocalPlayer().Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end
    end,
})
registerUIElement("NoclipToggle", NoclipToggle)
table.insert(allToggles, NoclipToggle)

getLocalPlayer().CharacterAdded:Connect(function()
    if NoclipToggle.CurrentValue then
        if Noclipping then
            Noclipping:Disconnect()
            Noclipping = nil
        end
        Noclipping = RunService.Stepped:Connect(NoclipLoop)
    end
end)

InfiniteJumpToggle = MovementTab:CreateToggle({
   Name = "Infinite Jump",
   CurrentValue = Settings.Movement.infiniteJumpEnabled,
   Flag = "InfiniteJumpToggle",
   Callback = function(Value)
      Settings.Movement.infiniteJumpEnabled = Value
      InfiniteJumpEnabled = Value

      if InfiniteJumpEnabled then
         if Connection then
            Connection:Disconnect()
         end

         Connection = UserInputService.JumpRequest:Connect(function()
            if InfiniteJumpEnabled then
                InfiniteJump()
            end
         end)
      else
         if Connection then
            Connection:Disconnect()
            Connection = nil
         end
      end
   end,
})
registerUIElement("InfiniteJumpToggle", InfiniteJumpToggle)
table.insert(allToggles, InfiniteJumpToggle)

game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function(char)
    wait(0.7)
    game.Players.LocalPlayer.Character.Humanoid.PlatformStand = false
    game.Players.LocalPlayer.Character.Animate.Disabled = false
end)

MovementTab:CreateToggle({
    Name = "Ignore Walkspeed Slider limit",
    CurrentValue = false,
    Flag = "IgnoreWalkSpeedLimit",
    Callback = function(Value)
        if Value then
            SpeedSlider2.Range = {0.01, 10}
        else
            SpeedSlider2.Range = {0.01, 0.22}
        end 
    end,
})

local ChatTab = Window:CreateTab("Misc", "loader-circle")

local OriginalSizes = {}
local ActivePlayers = {}
local HitboxSettings = {
    Enabled = false,
    HeadScale = 0.3,
    BodyScale = 0.15,
    UpdateRate = 0.2
}

local ToggleLock = false

local function ModifyHitbox(player)
    if ToggleLock then return end
    if not player or player == LocalPlayer or not player.Character then return end

    local character = player.Character
    ActivePlayers[player] = true

    local head = character:FindFirstChild("Head")
    if head then
        if not OriginalSizes[head] then
            OriginalSizes[head] = head.Size
        end
        head.Size = OriginalSizes[head] * (1 + HitboxSettings.HeadScale)
    end

    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and part ~= head then
            if not OriginalSizes[part] then
                OriginalSizes[part] = part.Size
            end
            part.Size = OriginalSizes[part] * (1 + HitboxSettings.BodyScale)
        end
    end
end

local function RestoreHitbox(player)
    if ToggleLock then return end
    if not player then return end

    if player.Character then
        for part, originalSize in pairs(OriginalSizes) do
            if part and part.Parent and part.Parent == player.Character then
                part.Size = originalSize
            end
        end
    end

    ActivePlayers[player] = nil
end

local function FullCleanup()
    for player, _ in pairs(ActivePlayers) do
        if player and player.Character then
            for part, originalSize in pairs(OriginalSizes) do
                if part and part.Parent == player.Character then
                    part.Size = originalSize
                end
            end
        end
    end
    table.clear(ActivePlayers)
    table.clear(OriginalSizes)
end

ExpanderToggle = ChatTab:CreateToggle({
    Name = "Hitbox Expander",
    CurrentValue = Settings.Misc.hitboxExpanderEnabled,
    Flag = "HitboxToggle",
    Callback = function(value)
        if ToggleLock then return end
        ToggleLock = true

        Settings.Misc.hitboxExpanderEnabled = value
        HitboxSettings.Enabled = value

        if value then

            for _, player in ipairs(getPlayers()) do
                if player ~= LocalPlayer then
                    ModifyHitbox(player)
                end
            end
        else

            FullCleanup()
        end

        ToggleLock = false
    end
})
registerUIElement("ExpanderToggle", ExpanderToggle)
table.insert(allToggles, ExpanderToggle)

HeadSizeSlider = ChatTab:CreateSlider({
    Name = "Head Size",
    Range = {0, 0.65},
    Increment = 0.05,
    Suffix = "x",
    CurrentValue = Settings.Misc.headScale,
    Flag = "HeadSizeSlider",
    Callback = function(value)
        Settings.Misc.headScale = value
        HitboxSettings.HeadScale = value
    end
})
registerUIElement("HeadSizeSlider", HeadSizeSlider)

BodySizeSlider = ChatTab:CreateSlider({
    Name = "Body Size",
    Range = {0, 0.95},
    Increment = 0.05,
    Suffix = "x",
    CurrentValue = Settings.Misc.bodyScale,
    Flag = "BodySizeSlider",
    Callback = function(value)
        Settings.Misc.bodyScale = value
        HitboxSettings.BodyScale = value
    end
})
registerUIElement("BodySizeSlider", BodySizeSlider)

local function TrackPlayer(player)
    if player == LocalPlayer then return end

    player.CharacterAdded:Connect(function(character)
        if HitboxSettings.Enabled then
            task.wait(0.5) 
            ModifyHitbox(player)
        end
    end)

    if player.Character and HitboxSettings.Enabled then
        task.defer(function()
            ModifyHitbox(player)
        end)
    end
end

for _, player in ipairs(getPlayers()) do
    TrackPlayer(player)
end

Players.PlayerAdded:Connect(TrackPlayer)

Players.PlayerRemoving:Connect(function(player)
    if ActivePlayers[player] then
        RestoreHitbox(player)
    end
end)

local lastUpdate = 0
RunService.Heartbeat:Connect(function()
    if not HitboxSettings.Enabled then return end

    local now = tick()
    if now - lastUpdate < HitboxSettings.UpdateRate then return end
    lastUpdate = now

    for player, _ in pairs(ActivePlayers) do
        if player and player.Character then
            ModifyHitbox(player)
        else
            ActivePlayers[player] = nil
        end
    end

    if HitboxSettings.Enabled then
        for _, player in ipairs(getPlayers()) do
            if player ~= LocalPlayer and not ActivePlayers[player] and player.Character then
                ModifyHitbox(player)
            end
        end
    end
end)

ChatSpyToggle = ChatTab:CreateToggle({
    Name = "ChatSpy",
    CurrentValue = Settings.Misc.chatSpyEnabled,
    Callback = function(Value)
        Settings.Misc.chatSpyEnabled = Value
        local TextChatService = game:GetService("TextChatService")
        if Value then
            TextChatService.ChatWindowConfiguration.Enabled = true
        else
            TextChatService.ChatWindowConfiguration.Enabled = false
        end
   end
})
registerUIElement("ChatSpyToggle", ChatSpyToggle)
table.insert(allToggles, ChatSpyToggle)

ChatTab:CreateButton({
    Name = "Infinite Yield",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    end
})

FOVSlider = ChatTab:CreateSlider({
    Name = "Camera FOV",
    Range = {30, 120},
    Increment = 1,
    CurrentValue = Settings.Misc.fovValue,
    Flag = "CameraFOV",
    Callback = function(Value)
        Settings.Misc.fovValue = Value
        _G.FOVValue = Value
        if not _G.FOVConnection then
            _G.FOVConnection = game:GetService("RunService").RenderStepped:Connect(function()
                local camera = game.Workspace.CurrentCamera
                if camera and _G.FOVValue then
                    camera.FieldOfView = _G.FOVValue
                end
            end)
        end
    end
})
registerUIElement("FOVSlider", FOVSlider)

ChatTab:CreateLabel("Default is 70 btw")

AntiAfkToggle = ChatTab:CreateToggle({
    Name = "Anti AFK",
    CurrentValue = Settings.Misc.antiAfkEnabled,
    Flag = "AntiAfkToggle",
    Callback = function(Value)
        Settings.Misc.antiAfkEnabled = Value
        if Value then
            local vu = game:GetService("VirtualUser")
            game:GetService("Players").LocalPlayer.Idled:connect(function()
                vu:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
                wait(1)
                vu:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
            end)
        end
    end,
})
registerUIElement("AntiAfkToggle", AntiAfkToggle)
table.insert(allToggles, AntiAfkToggle)

FPSLimitSlider = ChatTab:CreateSlider({
    Name = "FPS Limit",
    Range = {5, 500},
    Increment = 5,
    Suffix = "FPS",
    CurrentValue = Settings.Misc.fpsLimit,
    Flag = "FPSLimitSlider", 
    Callback = function(Value)
        Settings.Misc.fpsLimit = Value
        setfpscap(Value)
    end,
})
registerUIElement("FPSLimitSlider", FPSLimitSlider)

local FullBrightStrengthCap = 5

FullBrightToggle = ChatTab:CreateToggle({
    Name = "Full Bright",
    CurrentValue = Settings.Map.fullBrightEnabled,
    Flag = "FullBrightEnabled",
    Callback = function(Value)
        Settings.Map.fullBrightEnabled = Value
        if Value then
            Lighting.Ambient = Color3.fromRGB(255, 255, 255)
            Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
            Lighting.Brightness = FullBrightStrengthCap * (math.clamp(Settings.Map.fullBrightPercent, 0, 100) / 100)
            Lighting.ShadowSoftness = 0
            Lighting.GlobalShadows = false
        else
            Lighting.Ambient = Color3.fromRGB(127, 127, 127)
            Lighting.OutdoorAmbient = Color3.fromRGB(127, 127, 127)
            Lighting.Brightness = 1.0
            Lighting.ShadowSoftness = 0.3
            Lighting.GlobalShadows = true
        end
    end,
})
registerUIElement("FullBrightToggle", FullBrightToggle)
table.insert(allToggles, FullBrightToggle)

FullbrightStrengthSlider = ChatTab:CreateSlider({
    Name = "Fullbright Strength (Safe %)",
    Range = {0, 100},
    Increment = 1,
    Suffix = "%",
    CurrentValue = Settings.Map.fullBrightPercent,
    Callback = function(Value)
        Settings.Map.fullBrightPercent = math.clamp(Value, 0, 100)
        FullBrightPercent = Settings.Map.fullBrightPercent
        if FullBrightToggle and FullBrightToggle.CurrentValue then
            Lighting.Brightness = FullBrightStrengthCap * (Settings.Map.fullBrightPercent / 100)
        end
    end,
})
registerUIElement("FullbrightStrengthSlider", FullbrightStrengthSlider)

local function isWall(part)
    if not part:IsA("BasePart") then
        return false
    end
    local nameLower = string.lower(part.Name)
    if string.find(nameLower, "wall") or 
       string.find(nameLower, "barrier") or
       string.find(nameLower, "fence") then
        return true
    end
    local orientation = part.Orientation
    if (math.abs(orientation.X) > 80 or math.abs(orientation.Z) > 80) then
        if part.Size.Y > part.Size.X and part.Size.Y > part.Size.Z then
            return true
        end
    end
    if (part.Size.X < 3 or part.Size.Z < 3) and part.Size.Y > 5 then
        return true
    end
    return false
end

local function isDoor(part)
    if not part:IsA("BasePart") then
        return false
    end
    local nameLower = string.lower(part.Name)
    if string.find(nameLower, "door") or 
       string.find(nameLower, "gate") or
       string.find(nameLower, "entrance") then
        return true
    end
    if part.Parent and string.lower(part.Parent.Name):find("door") then
        return true
    end
    return false
end

ChatTab:CreateButton({
   Name = "Simplify Map",
   Info = "Destroys only some walls and doors",
   Callback = function()
        local wallsDestroyed = 0
        local doorsDestroyed = 0
        local descendants = workspace:GetDescendants()
        for _, obj in ipairs(descendants) do
            if isWall(obj) then
                wallsDestroyed = wallsDestroyed + 1
                obj:Destroy()
            elseif isDoor(obj) then
                doorsDestroyed = doorsDestroyed + 1
                obj:Destroy()
            end
        end
        Rayfield:Notify({
            Title = "DESTRUCTION COMPLETE",
            Content = wallsDestroyed .. " walls and " .. doorsDestroyed .. " doors destroyed.",
            Duration = 3
        })
   end,
})

ChatTab:CreateButton({
   Name = "Destroy All Doors",
   Info = "Destroys all door-like parts",
   Callback = function()
        local doorsDestroyed = 0
        for _, obj in ipairs(workspace:GetDescendants()) do
            if isDoor(obj) then
                doorsDestroyed = doorsDestroyed + 1
                obj:Destroy()
            end
        end
        Rayfield:Notify({
            Title = "All Doors Destroyed",
            Content = tostring(doorsDestroyed) .. " doors destroyed.",
            Duration = 3
        })
   end,
})

ModDetectionActive = false
ModDetectionConnection = nil
LoopRunning = false

local function ModDetection(enabled)
    if ModDetectionActive == enabled then
        return
    end

    ModDetectionActive = enabled

    local function CheckForMods()
        if not ModDetectionActive then return false end

        for _, Player in ipairs(getPlayers()) do
            if isModerator(Player) then
                wait(0.5) 
                game.Players.LocalPlayer:Kick("Mod detected! Mod name: " .. Player.Name)
                return true
            end
        end
        return false
    end

    if ModDetectionActive then

        if CheckForMods() then return end

        if ModDetectionConnection then
            ModDetectionConnection:Disconnect()
        end
        
        ModDetectionConnection = game.Players.PlayerAdded:Connect(function(Player)
            if not ModDetectionActive then return end
            wait(2)

            if isModerator(Player) then
                wait(0.5) 
                game.Players.LocalPlayer:Kick("Mod detected! Mod name: " .. Player.Name)
            end
        end)

        if not LoopRunning then
            LoopRunning = true
            task.spawn(function()
                while ModDetectionActive do
                    wait(10)
                    if not ModDetectionActive then
                        LoopRunning = false
                        break
                    end
                    if CheckForMods() then break end
                end
            end)
        end
    else

        if ModDetectionConnection then
            ModDetectionConnection:Disconnect()
            ModDetectionConnection = nil
        end
        LoopRunning = false
    end
end

local ModTab = Window:CreateTab("Anti-Moderation & Magnesium", "gavel")

local DisableAllButton = ModTab:CreateButton({
    Name = "Disable All Features",
    Info = "Instantly disables all features",
    Callback = function()
        local disabledCount = 0

        for _, toggle in pairs(allToggles) do
            pcall(function()
                if toggle and toggle.CurrentValue and toggle.Set then
                    toggle:Set(false)
                    disabledCount = disabledCount + 1
                end
            end)
        end

        pcall(function()
            Rayfield:Notify({
                Title = "All Features Disabled",
                Content = disabledCount .. " features disabled",
                Duration = 3,
                Image = 4384403532
            })
        end)

        print("Disabled " .. disabledCount .. " features") 
    end,
})

AutoLeaveToggle = ModTab:CreateToggle({
    Name = "Auto Leave",
    CurrentValue = false,
    Flag = "ModDetection",
    Callback = function(Value)
        ModDetection(Value)
    end,
})
registerUIElement("AutoLeaveToggle", AutoLeaveToggle)
table.insert(allToggles, AutoLeaveToggle)

notifyOnModJoin = true
disableOnModJoin = true

ModJoinNotifyToggle = ModTab:CreateToggle({
    Name = "Notify me when moderator joins the game",
    CurrentValue = Settings.AntiMod.modJoinNotify,
    Flag = "ModJoinNotify",
    Callback = function(Value)
        Settings.AntiMod.modJoinNotify = Value
        notifyOnModJoin = Value
    end
})
registerUIElement("ModJoinNotifyToggle", ModJoinNotifyToggle)
table.insert(allToggles, ModJoinNotifyToggle)

DisableOnModJoinToggle = ModTab:CreateToggle({
    Name = "Disable everything when moderator joins the game",
    CurrentValue = Settings.AntiMod.disableOnModJoin,
    Flag = "DisableOnModJoin",
    Callback = function(Value)
        Settings.AntiMod.disableOnModJoin = Value
        disableOnModJoin = Value
    end
})
registerUIElement("DisableOnModJoinToggle", DisableOnModJoinToggle)
table.insert(allToggles, DisableOnModJoinToggle)

for _, player in ipairs(getPlayers()) do
    if isModerator(player) then
        if notifyOnModJoin then
            Rayfield:Notify({
                Title = "Moderator Detected!",
                Content = "Mod Name: " .. player.Name,
                Duration = 20,
                Image = "gavel"
            })
        end
        break 
    end
end

Players.PlayerAdded:Connect(function(player)
    if isModerator(player) then
        if notifyOnModJoin then
            Rayfield:Notify({
                Title = "Moderator Detected!",
                Content = "Mod Name: " .. player.Name,
                Duration = 20,
                Image = "gavel"
            })
        end
        if disableOnModJoin then
            disableAllToggles()
            Rayfield:Notify({
                Title = "Security Alert",
                Content = "All toggles disabled due to moderator join.",
                Duration = 3,
                Image = 4384403532
            })
        end
    end
end)

local resetOnModJoin = false
local moderatorJoinCount = 0

ResetOnModJoinToggle = ModTab:CreateToggle({
    Name = "Reset character when moderator joins the game",
    CurrentValue = Settings.AntiMod.resetOnModJoin,
    Flag = "ResetOnModJoin",
    Callback = function(Value)
        Settings.AntiMod.resetOnModJoin = Value
        resetOnModJoin = Value

        if Value then
            moderatorJoinCount = 0
        end
    end
})
registerUIElement("ResetOnModJoinToggle", ResetOnModJoinToggle)
table.insert(allToggles, ResetOnModJoinToggle)

Players.PlayerAdded:Connect(function(player)
    if isModerator(player) and resetOnModJoin then
        moderatorJoinCount = moderatorJoinCount + 1

        if moderatorJoinCount == 1 then
            pcall(function()
                game.Players.LocalPlayer.Character.Humanoid.Health = 0
            end)
            Rayfield:Notify({
                Title = "Character Reset",
                Content = "Character reset due to first moderator join.",
                Duration = 3,
                Image = 4384403532
            })
        end
    end
end)

ModTab:CreateParagraph({
    Title = "ANTI-MOD INFORMATION",
    Content = 
        "Some features like Infinite Yield and Camera FOV cannot be disabled automatically and may remain active when a moderator joins. Use them at your own risk.\n\n" ..
        "Auto Leave is effective but risky  instantly leaving when a mod joins can look suspicious.\n\n" ..
        "Recommended Setup:\n" ..
        "- Notify me when a moderator joins: Enabled\n" ..
        "- Auto Leave: Disabled (unless you want 100% safety at the cost of being obvious)\n" ..
        "- Disable everything when a moderator joins: Enabled\n" ..
        "- Reset character when moderator joins: Recommended - when using movement cheats\n\n" ..
        "also remember mods are retarded"
})

table.insert(allToggles, ESPMasterToggle)
table.insert(allToggles, BoxesToggle)
table.insert(allToggles, NamesToggle)
table.insert(allToggles, TracersToggle)
table.insert(allToggles, HealthBarsToggle)
table.insert(allToggles, ShowHealthNumberToggle)
table.insert(allToggles, ShowDistanceToggle)
table.insert(allToggles, TeamColorsToggle)
table.insert(allToggles, Toggle)
table.insert(allToggles, ExpanderToggle)
table.insert(allToggles, AutoLeaveToggle)
table.insert(allToggles, ModJoinNotifyToggle)
table.insert(allToggles, DisableOnModJoinToggle)
table.insert(allToggles, ResetOnModJoinToggle)

Players.PlayerRemoving:Connect(function(player)
    if player == getLocalPlayer() and Noclipping then
        Noclipping:Disconnect()
    end
end)


RunService.Heartbeat:Connect(updateESP)

game:GetService("Players").PlayerRemoving:Connect(function(player)
   if player == getLocalPlayer() then
      stopMobileAimbot()
      destroyMobileFovCircle()
      
      Rayfield:Destroy()
   end
end)

game:GetService("CoreGui").ChildRemoved:Connect(function(child)
    if child.Name == "Rayfield" then
        if Connection then
            Connection:Disconnect()
        end
        stopMobileAimbot()
        destroyMobileFovCircle()
    end
end)

Players.PlayerRemoving:Connect(function(player)
    cleanupESPElement(player)

    if lastTargetPart[player] then
        lastTargetPart[player] = nil
    end
end)
